# -*- coding: utf-8 -*-
"""Examining_Building_FootPrints.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1a4NLPufzwgsYl3g9VdVqYC7O9XO58UEf

# Task
Examine Building Footprints:

Load the KML file and visualize building density across Manhattan and the Bronx.
Consider how you might derive a “building density” or “impervious surface fraction” feature.

Context:
Building Footprints (Building_Footprint.kml): Many studies suggest that the density of buildings in a city influences ground temperatures and ultimately contribute to the UHI issue. [Reference 3] This effect is typically driven by buildings blocking the flow of air and adding waste heat. For this challenge, we have provided a building footprint dataset. Such information could be used in your digital model as a feature that drives local urban heating. Figure 4. Higher building density is known to increase local air temperatures and contribute to the UHI effect. Data challenge participants will be given building footprint data for consideration in their digital models.

Here is all the data you need:
"Building_Footprint.kml.txt"

## Data loading

### Subtask:
Load the KML file "Building_Footprint.kml.txt" into a GeoDataFrame.

**Reasoning**:
Load the KML file into a GeoDataFrame and inspect the first few rows to verify the data.
"""

import geopandas as gpd
# import pandas as pd
import numpy as np
from shapely.geometry import Polygon
import matplotlib.pyplot as plt

# 1. Data Loading

try:
    # Attempt to read the KML file into a GeoDataFrame
    # buildings = gpd.read_file("Building_Footprint.kml.txt")
    # Load the building footprints KML file
    kml_path = r"e:\01-Projects\2025datachallenge\src\Building_Footprint.kml"
    buildings = gpd.read_file(kml_path, driver='KML')

    # Display the first few rows of the GeoDataFrame
    # display(buildings.head())

    # Print information about the GeoDataFrame
    print(buildings.info())
    print(f"CRS: {buildings.crs}")

except FileNotFoundError:
    print("Error: 'Building_Footprint.kml.txt' not found.")
except Exception as e:
    print(f"An error occurred: {e}")

"""## Data exploration

### Subtask:
Explore the loaded building footprint data.

**Reasoning**:
Check the CRS, reproject if necessary, analyze attributes, calculate summary statistics, determine spatial extent, visualize the data, and identify any missing or invalid geometries.
"""

# 2. Data Exploration & Reprojection

# Check and reproject the CRS if needed
if buildings.crs != "EPSG:2263":
    print("Reprojecting to EPSG:2263")
    buildings = buildings.to_crs(epsg=2263)
    print(f"New CRS: {buildings.crs}")

# Analyze attributes and calculate summary statistics
print("\nAttribute Analysis and Summary Statistics:")
print(buildings.describe())

# Check for missing values
print("\nMissing Values:")
print(buildings.isnull().sum())

# Determine spatial extent
minx, miny, maxx, maxy = buildings.total_bounds
print("\nSpatial Extent:")
print(f"Min X: {minx}, Min Y: {miny}, Max X: {maxx}, Max Y: {maxy}")

# Visualize the building footprints
plt.figure(figsize=(10, 8))  # Adjust figure size for better visualization
buildings.plot(column='Name', cmap='viridis', alpha=0.5, legend=True) # Use color to differentiate buildings
plt.title("Building Footprints in Manhattan and the Bronx")
plt.xlabel("Longitude")
plt.ylabel("Latitude")

# Check for invalid geometries
invalid_geometries = buildings[~buildings.is_valid]
print(f"\nNumber of invalid geometries: {len(invalid_geometries)}")
if len(invalid_geometries) > 0:
    print(invalid_geometries)

"""## Data wrangling

### Subtask:
Prepare the data for density calculations.

**Reasoning**:
Create a grid, calculate building footprint areas, and join the grid with the building footprints.  Since building height data is not available, I will skip adding a 'building_height' column.
"""

# 3. Data Wrangling: Create a 100m grid and calculate building density


# 1. Create a grid
# Determine grid cell dimensions based on spatial extent
minx, miny, maxx, maxy = buildings.total_bounds
cell_size = 100  # Adjust as needed (in meters)
grid_x = np.arange(minx, maxx, cell_size)
grid_y = np.arange(miny, maxy, cell_size)


grid_cells = []
for x in grid_x:
    for y in grid_y:
        cell = Polygon([(x, y), (x + cell_size, y), (x + cell_size, y + cell_size), (x, y + cell_size)])
        grid_cells.append(cell)
grid = gpd.GeoDataFrame(geometry=grid_cells, crs=buildings.crs)


# 2. Calculate the area of each building footprint
buildings['footprint_area'] = buildings.geometry.area

# 4. Spatial Join
# Perform a spatial join between the grid and building footprints
joined_data = gpd.sjoin(grid, buildings, how="left", predicate="intersects")

# Calculate the total footprint area within each grid cell
grid_footprint_area = joined_data.groupby(joined_data.index)['footprint_area'].sum().reset_index()
grid = grid.merge(grid_footprint_area, left_index=True, right_on='index')

# # Display the first few rows of the joined data
# display(grid.head())

"""## Feature engineering

### Subtask:
Calculate building density and impervious surface fraction.

**Reasoning**:
Calculate building density and impervious surface fraction, and explore different grid sizes.
"""

# Calculate building density
grid['building_count'] = joined_data.groupby(joined_data.index)['index_right'].count().reindex(grid.index).fillna(0)
grid['building_density'] = grid['building_count'] / (cell_size**2)

# Calculate impervious surface fraction
grid['impervious_surface_fraction'] = grid['footprint_area'] / (cell_size**2)

# Export the 100m grid as a shapefile for later integration
grid.to_file("grid_100m.shp", driver="ESRI Shapefile")

# Immediately reload and inspect the file
grid_check = gpd.read_file("grid_100m.shp")
print("Columns in exported grid:", grid_check.columns)
print(grid_check.head())

# Explore different grid sizes (e.g., 50m, 200m)
cell_sizes = [50, 200]
grids = {}
for cell_size in cell_sizes:
    # Create a new grid
    grid_x = np.arange(minx, maxx, cell_size)
    grid_y = np.arange(miny, maxy, cell_size)
    grid_cells = []
    for x in grid_x:
        for y in grid_y:
            cell = Polygon([(x, y), (x + cell_size, y), (x + cell_size, y + cell_size), (x, y + cell_size)])
            grid_cells.append(cell)
    new_grid = gpd.GeoDataFrame(geometry=grid_cells, crs=buildings.crs)

    # Spatial join
    joined_data = gpd.sjoin(new_grid, buildings, how="left", predicate="intersects")

    # Calculate total footprint area within each grid cell
    grid_footprint_area = joined_data.groupby(joined_data.index)['footprint_area'].sum().reset_index()
    new_grid = new_grid.merge(grid_footprint_area, left_index=True, right_on='index')

    # Calculate building density and impervious surface fraction
    new_grid['building_count'] = joined_data.groupby(joined_data.index)['index_right'].count().reindex(new_grid.index).fillna(0)
    new_grid['building_density'] = new_grid['building_count'] / (cell_size**2)
    new_grid['impervious_surface_fraction'] = new_grid['footprint_area'] / (cell_size**2)

    # Store the results
    grids[f'grid_{cell_size}m'] = new_grid

# Explicitly assign grid_50m and grid_200m
grid_50m = grids['grid_50m']
grid_200m = grids['grid_200m']

# Export the 50m grid as a shapefile
grid_50m.to_file("grid_50m.shp", driver="ESRI Shapefile")

# Export the 200m grid as a shapefile
grid_200m.to_file("grid_200m.shp", driver="ESRI Shapefile")


# Immediately reload and inspect the file
grid_check = gpd.read_file("grid_50m.shp")
print("Columns in exported grid:", grid_check.columns)
print(grid_check.head())

# Immediately reload and inspect the file
grid_check = gpd.read_file("grid_200m.shp")
print("Columns in exported grid:", grid_check.columns)
print(grid_check.head())


# # Display the first few rows of the updated grid
# display(grid.head())
# display(grid_50m.head())
# display(grid_200m.head())

"""## Data visualization

### Subtask:
Visualize the building density and impervious surface fraction across Manhattan and the Bronx.

**Reasoning**:
Create choropleth maps for building density and impervious surface fraction, overlay building footprints, and generate histograms for each grid.
"""



# Function to create choropleth maps and histograms
def visualize_grid(grid_df, title_suffix):
    fig, axes = plt.subplots(nrows=2, ncols=2, figsize=(15, 12))

    # Choropleth map for building density
    grid_df.plot(column='building_density', cmap='viridis', linewidth=0.1, ax=axes[0, 0], legend=True)
    buildings.plot(ax=axes[0, 0], color='grey', alpha=0.5)
    axes[0, 0].set_title(f'Building Density ({title_suffix})')

    # Choropleth map for impervious surface fraction
    grid_df.plot(column='impervious_surface_fraction', cmap='plasma', linewidth=0.1, ax=axes[0, 1], legend=True)
    buildings.plot(ax=axes[0, 1], color='grey', alpha=0.5)
    axes[0, 1].set_title(f'Impervious Surface Fraction ({title_suffix})')

    # Histogram for building density
    grid_df['building_density'].plot.hist(ax=axes[1, 0], color='skyblue')
    axes[1, 0].set_title(f'Building Density Histogram ({title_suffix})')
    axes[1, 0].set_xlabel('Building Density')

    # Histogram for impervious surface fraction
    grid_df['impervious_surface_fraction'].plot.hist(ax=axes[1, 1], color='salmon')
    axes[1, 1].set_title(f'Impervious Surface Fraction Histogram ({title_suffix})')
    axes[1, 1].set_xlabel('Impervious Surface Fraction')

    plt.tight_layout()
    # plt.show()

# Visualize each grid
visualize_grid(grid, '100m')
visualize_grid(grid_50m, '50m')
visualize_grid(grid_200m, '200m')

"""## Summary:

### 1. Q&A

* **How might you derive a “building density” or “impervious surface fraction” feature?** Building density was derived by counting the number of buildings within each grid cell and dividing by the grid cell area. Impervious surface fraction was calculated by summing the area of building footprints within each grid cell and dividing by the grid cell area.  Multiple grid sizes (50m, 100m, and 200m) were used to explore the impact of grid resolution on these calculations.


### 2. Data Analysis Key Findings

* **Data Quality Issues:** The KML file contained repeated 'Name' and 'Description' values and only two unique geometry entries for all of the buildings in the file. This suggests data redundancy and potentially incorrect data entries. Two invalid geometries were also identified and require further investigation.
* **Grid Resolution Impact:** Building density and impervious surface fraction calculations varied with different grid cell sizes (50m, 100m, and 200m).  A finer grid (50m) would likely capture more detail, but a coarser grid (200m) might be more computationally efficient and offer a more generalized representation of the data.
* **Spatial Distribution:** Visualizations (choropleth maps) revealed the spatial distribution of building density and impervious surface fraction across Manhattan and the Bronx.  Most grid cells had zero building counts and zero footprint area. This suggests there may be large areas of no buildings and the visualizations may be inaccurate due to the invalid geometries and repeated/incorrect data entries.


### 3. Insights or Next Steps

* **Data Cleaning and Validation:** Prioritize cleaning the building footprint data. Investigate the repeated and invalid geometry entries. Correct or remove these anomalies to ensure reliable density calculations and visualizations.
* **Grid Optimization:** Experiment with additional grid resolutions and evaluate their impact on building density and impervious surface fraction calculations.  Determine the optimal grid size that balances detail and computational cost. Further visualization with the cleaned data is required to understand the accuracy of the calculated features.

"""